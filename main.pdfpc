{"pdfpcFormat":2,"disableMarkdown":false,"pages":[{"idx":0,"label":1,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":1,"label":2,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":2,"label":3,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"- In recent years, Memory Safety of Applications and Programming Languages has received increasing interest. Due to an increasing dependence of our privacy on the security of digital systems, memory safety as one piece of secure systems, is becoming more and more important.\n  - However, experience hash shown time and time again, that high-impact vulnerabilities due to memory unsafety are virtually unavoidable in large projects written in C/C++.\n  - A recent examination of the high severity security impacting bugs in Chromium revealed that 70 % are due to memory unsafety. And, this is corroborated by other large projects, such as Windows and Android.\n  - This is relevant, as MPC applications are networked services, potentially exposed to the Internet, and which are usually written in C/C++. \n  - The Memory Safety of these applications will becomer more important as MPC progesses from research to real-world deployments.\n  - The reason C/C++ are so often used in MPC, is the performance and efficiency of the resulting implementations.\n  [NEXT SLIDE]\n  - To shift MPC from the largely theoretical to the practical we need to optimize its performance and efficiency\n  - One aspect of efficiency which we've focused on with SEEC, is memory efficiency\n  - This is especially relevant if we want to target mobile devices, where the most common RAM configuration was 4 GB in 2022.\n  - But it's also relevant to deployments on servers, where reduced memory consumption can allow us to tackle larger problems or reduce operating costs"},{"idx":3,"label":3,"overlay":1,"forcedOverlay":true,"hidden":false,"note":"- In recent years, Memory Safety of Applications and Programming Languages has received increasing interest. Due to an increasing dependence of our privacy on the security of digital systems, memory safety as one piece of secure systems, is becoming more and more important.\n  - However, experience hash shown time and time again, that high-impact vulnerabilities due to memory unsafety are virtually unavoidable in large projects written in C/C++.\n  - A recent examination of the high severity security impacting bugs in Chromium revealed that 70 % are due to memory unsafety. And, this is corroborated by other large projects, such as Windows and Android.\n  - This is relevant, as MPC applications are networked services, potentially exposed to the Internet, and which are usually written in C/C++. \n  - The Memory Safety of these applications will becomer more important as MPC progesses from research to real-world deployments.\n  - The reason C/C++ are so often used in MPC, is the performance and efficiency of the resulting implementations.\n  [NEXT SLIDE]\n  - To shift MPC from the largely theoretical to the practical we need to optimize its performance and efficiency\n  - One aspect of efficiency which we've focused on with SEEC, is memory efficiency\n  - This is especially relevant if we want to target mobile devices, where the most common RAM configuration was 4 GB in 2022.\n  - But it's also relevant to deployments on servers, where reduced memory consumption can allow us to tackle larger problems or reduce operating costs"},{"idx":4,"label":4,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"- Okay, so what do we contribute with SEEC?\n- Because we wanted to achieve a memory safe and efficient MPC framework, which also provides good performance and a nice developer experience, we choose the programming language Rust for our implementation.\n- It's a memory safe language, with performance similar to C/C++, control over memory allocations without garbage collection, and a good developer experience due to fantastic tooling."},{"idx":5,"label":5,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":6,"label":6,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"- in traditional programs, functions are an important tool for building abstractions and organizing code\n- they also reduce the size of the binary, inlining every function would result in a tremendous overhead\n  - yet, this is exactly what we often do in MPC"},{"idx":7,"label":7,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"- ideally when using MPC to securely evaluate a functionality, we want to express it in a high-level way\n  - this should include the capability for using functions\n  - code should be fairly close to traditional code, to ease development of MPC applications\n  - some slight differences such as the changed types here, are okay; and likely necessary\n- crucially, we want to not only use functions for organization, but also for reduced memory consumption during the MPC protocol's evaluation\n- this is important for the real world deployment of MPC, where we might operate on memory-constrained devices or have very large  inputs\n- with our work SEEC, we have implemented and extensively benchmarked and compared one possible solution"},{"idx":8,"label":8,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"TODO: Maybe animate this slide"},{"idx":9,"label":8,"overlay":1,"forcedOverlay":true,"hidden":false,"note":"TODO: Maybe animate this slide"},{"idx":10,"label":8,"overlay":2,"forcedOverlay":true,"hidden":false,"note":"TODO: Maybe animate this slide"},{"idx":11,"label":9,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":12,"label":9,"overlay":1,"forcedOverlay":true,"hidden":false},{"idx":13,"label":10,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":14,"label":10,"overlay":1,"forcedOverlay":true,"hidden":false},{"idx":15,"label":11,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":16,"label":11,"overlay":1,"forcedOverlay":true,"hidden":false},{"idx":17,"label":12,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"- TODO: Explain optimizations\n- text ist zu erschlagend\n- spacing etwas erhöhen, text vllt. etwas kleiner\n- maybe auch vorherige scritte ausgrauen"},{"idx":18,"label":12,"overlay":1,"forcedOverlay":true,"hidden":false,"note":"- TODO: Explain optimizations\n- text ist zu erschlagend\n- spacing etwas erhöhen, text vllt. etwas kleiner\n- maybe auch vorherige scritte ausgrauen"},{"idx":19,"label":12,"overlay":2,"forcedOverlay":true,"hidden":false,"note":"- TODO: Explain optimizations\n- text ist zu erschlagend\n- spacing etwas erhöhen, text vllt. etwas kleiner\n- maybe auch vorherige scritte ausgrauen"},{"idx":20,"label":13,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"- Why did we choose these frameworks?\n\n- explain net settings\n- hardware: two simx servers \n- mention bench tool\n\n\n- bench sub-circuit via AES CBC circuit\n- bench SIMD via parallel AES and SHA-256 circuits\n\nTODO make clear that we use 2-party semi-hones GMW"},{"idx":21,"label":13,"overlay":1,"forcedOverlay":true,"hidden":false,"note":"- Why did we choose these frameworks?\n\n- explain net settings\n- hardware: two simx servers \n- mention bench tool\n\n\n- bench sub-circuit via AES CBC circuit\n- bench SIMD via parallel AES and SHA-256 circuits\n\nTODO make clear that we use 2-party semi-hones GMW"},{"idx":22,"label":14,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"- 50 GB\n- 2.2 GB\n- 375 MB"},{"idx":23,"label":15,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"- at 10k:\n  - 210 MB for MP-SPDZ\n  - 375 MB for SEEC\n- MOTION at 100:\n  - ~73 GB"},{"idx":24,"label":16,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"- just SL: No opts: 7.5 GB\n- FG: 3.1 GB\n- SEEC: ~ 700 MB"},{"idx":25,"label":17,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"- at 1M:\n  - MOTION: 10 GB\n  - SEEC: ~ 700 MB"},{"idx":26,"label":18,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"100 chained AES blocks\n- WAN: MOTION 423 s and MP-SPDZ 616 s"},{"idx":27,"label":19,"overlay":0,"forcedOverlay":false,"hidden":false,"note":"Mem. Reduction via Sub-Circuits\n- support for loops and register allocation of gate outputs can lead to better memory efficiency in some cases (MP-SPDZ)\n- however sub-circuits are more versatile, as they can reduce memory consumption of sub-circuit calls at unrelated places of the main circuit\nSIMD\n- Significantly better SIMD memory consumption\n  - largely due to FG and IS optimizations\n- Async. Eval. of MOTION has bad perf. for scalar circs but good for massively parallel circs (high SIMD size)\n- LBL execution of ABY, MP-SPDZ and SEEC is better for scalar circs\n- Network setting can have non-obvious impacts on online perf.\n- Predicatbility\n- Realiability"},{"idx":28,"label":20,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":29,"label":21,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":30,"label":22,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":31,"label":23,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":32,"label":24,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":33,"label":25,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":34,"label":26,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":35,"label":27,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":36,"label":28,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":37,"label":29,"overlay":0,"forcedOverlay":false,"hidden":false},{"idx":38,"label":30,"overlay":0,"forcedOverlay":false,"hidden":false}]}